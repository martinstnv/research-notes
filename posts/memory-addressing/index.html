<!doctype html><html lang=en-us><head><title>Memory Addressing // Research Notes</title>
<link rel="shortcut icon" href=favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.127.0"><meta name=format-detection content="telephone=no"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Martin Stoynov"><meta name=description content><link rel=stylesheet href=/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css><link rel=stylesheet href=/custom.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Memory Addressing"><meta name=twitter:description content="How a CPU’s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.
A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as 0000 0000 0000 0000 0000 0000 0000 0000."><meta property="og:url" content="/posts/memory-addressing/"><meta property="og:site_name" content="Research Notes"><meta property="og:title" content="Memory Addressing"><meta property="og:description" content="How a CPU’s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.
A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as 0000 0000 0000 0000 0000 0000 0000 0000."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-30T00:00:00+00:00"><meta property="article:tag" content="Memory Addressing"><meta property="article:tag" content="Memory Space"><meta property="article:tag" content="Physical Memory"><meta property="article:tag" content="Addressable Memory"><meta property="article:tag" content="Virtual Memory"><meta property="article:tag" content="Endianess"><link rel=alternate type=application/rss+xml href=/index.xml title="Research Notes"></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Martin Stoynov"></a><h1>Research Notes</h1><nav class=app-header-menu><a class=app-header-menu-item href=/posts/>Posts</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>A Zettelkasten-style digital garden of evolving research notes.</p><div class=app-header-social><a href=https://github.com/martinstnv target=_blank rel="noreferrer noopener"><svg class="icon icon-github" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://linkedin.com/in/martinstnv target=_blank rel="noreferrer noopener"><svg class="icon icon-linkedin" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>linkedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=https://infosec.exchange/@martinstnv target=_blank rel="noreferrer noopener"><svg class="icon icon-brand-mastodon" viewBox="0 0 24 24" fill="currentcolor"><title>Mastodon</title><path d="M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792.0 11.813.0h-.03c-3.98.0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057.0 00.023-.043v-1.809a.052.052.0 00-.02-.041.053.053.0 00-.046-.01 20.282 20.282.0 01-4.709.545c-2.73.0-3.463-1.284-3.674-1.818a5.593 5.593.0 01-.319-1.433.053.053.0 01.066-.054c1.517.363 3.072.546 4.632.546.376.0.75.0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23.0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112.0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311.0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13.0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Memory Addressing</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Nov 30, 2025</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a class=tag href=/tags/memory-addressing/>Memory Addressing</a>
<a class=tag href=/tags/memory-space/>Memory Space</a>
<a class=tag href=/tags/physical-memory/>Physical Memory</a>
<a class=tag href=/tags/addressable-memory/>Addressable Memory</a>
<a class=tag href=/tags/virtual-memory/>Virtual Memory</a>
<a class=tag href=/tags/endianess/>Endianess</a>
<a class=tag href=/tags/word-size/>Word Size</a>
<a class=tag href=/tags/memory-access/>Memory Access</a></div></div></header><div class=post-content><blockquote><p>How a CPU’s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.</p></blockquote><p>A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as <code>0000 0000 0000 0000 0000 0000 0000 0000</code>. Following the same logic, the highest memory address in binary is <code>1111 1111 1111 1111 1111 1111 1111 1111</code>.</p><h2 id=memory-space>Memory Space</h2><p>By convention, memory addresses are often written in hexadecimal format. In this notation, the lowest address is <code>0x00000000</code> and the highest address is <code>0xFFFFFFFF</code>, since each group of four binary digits corresponds to a single hexadecimal digit, with <code>0000</code> equaling 0x0 and <code>1111</code> equaling <code>0xF</code>.</p><p>The highest address in a 32-bit memory space can also be expressed as <code>2^{32} - 1</code>, since the address count starts from 0, or as 4,294,967,295 in decimal. Using this, we can calculate the total size of the memory space as follows:</p><table><thead><tr><th>Binary representation</th><th>Power of 2</th><th>Calculation</th><th>Decimal representation</th></tr></thead><tbody><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0000</code></td><td>0</td><td>0</td><td>0</td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0001</code></td><td>2^{0}</td><td>1</td><td>1</td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0010</code></td><td>2^{1}</td><td>2 x 1</td><td>2</td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0100</code></td><td>2^{2}</td><td>2 x 2</td><td>4</td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1000</code></td><td>2^{3}</td><td>2 x 2 x 2</td><td>8</td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0001 0000</code></td><td>2^{4}</td><td>2 x 2 x 2 x 2</td><td>16</td></tr><tr><td><code>0000 0000 0000 0000 0000 0001 0000 0000</code></td><td>2^{8}</td><td>16 x 16</td><td>256</td></tr><tr><td><code>0000 0000 0000 0000 0001 0000 0000 0000</code></td><td>2^{12}</td><td>16 x 16 x 16</td><td>4,096</td></tr><tr><td><code>0000 0000 0000 0001 0000 0000 0000 0000</code></td><td>2^{16}</td><td>16 x 16 x 16 x 16</td><td>65,536</td></tr><tr><td><code>0000 0000 0001 0000 0000 0000 0000 0000</code></td><td>2^{20}</td><td>16 x 65,536</td><td>1,048,576</td></tr><tr><td><code>0000 0001 0000 0000 0000 0000 0000 0000</code></td><td>2^{24}</td><td>16 x 1,048,576</td><td>16,777,216</td></tr><tr><td><code>0001 0000 0000 0000 0000 0000 0000 0000</code></td><td>2^{28}</td><td>16 x 16,777,216</td><td>268,435,456</td></tr><tr><td><code>1111 1111 1111 1111 1111 1111 1111 1111</code></td><td>2^{32} - 1</td><td>16 x 268,435,456 - 1</td><td>4,294,967,295</td></tr></tbody></table><p>In comparison, the highest memory address of a 64-bit architecture would be:</p><table><thead><tr><th>Binary representation</th><th>Power of 2</th><th>Calculation</th><th>Decimal representation</th></tr></thead><tbody><tr><td><code>1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111</code></td><td>2^{64} - 1</td><td>268,435,456 x 268,435,456 - 1</td><td>18 446 744 065 119 617 025</td></tr></tbody></table><p>So what exactly does this memory space mean?</p><p>Each memory address corresponds to 1 byte in memory. For example:</p><table><thead><tr><th>Address (binary)</th><th>Address (hex)</th><th>Data (binary)</th><th>Data (hex)</th></tr></thead><tbody><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0000</code></td><td><code>0x00000000</code></td><td><code>0000 0000</code></td><td><code>0x00</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0001</code></td><td><code>0x00000001</code></td><td><code>0000 1111</code></td><td><code>0x0F</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0010</code></td><td><code>0x00000002</code></td><td><code>0001 0000</code></td><td><code>0x10</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0011</code></td><td><code>0x00000003</code></td><td><code>0001 0001</code></td><td><code>0x11</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0100</code></td><td><code>0x00000004</code></td><td><code>0001 0010</code></td><td><code>0x12</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0101</code></td><td><code>0x00000005</code></td><td><code>0001 1010</code></td><td><code>0x1A</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0110</code></td><td><code>0x00000006</code></td><td><code>0001 1111</code></td><td><code>0x1F</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 0111</code></td><td><code>0x00000007</code></td><td><code>0010 0000</code></td><td><code>0x20</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1000</code></td><td><code>0x00000008</code></td><td><code>0010 0100</code></td><td><code>0x24</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1001</code></td><td><code>0x00000009</code></td><td><code>0010 1111</code></td><td><code>0x2F</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1010</code></td><td><code>0x0000000A</code></td><td><code>0011 1111</code></td><td><code>0x3F</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1011</code></td><td><code>0x0000000B</code></td><td><code>0100 1111</code></td><td><code>0x4F</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1100</code></td><td><code>0x0000000C</code></td><td><code>1000 1111</code></td><td><code>0x8F</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1101</code></td><td><code>0x0000000D</code></td><td><code>1010 1111</code></td><td><code>0xAF</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1110</code></td><td><code>0x0000000E</code></td><td><code>1111 1111</code></td><td><code>0xFF</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0000 1111</code></td><td><code>0x0000000F</code></td><td><code>1010 1010</code></td><td><code>0xAA</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0001 0000</code></td><td><code>0x00000010</code></td><td><code>0101 0101</code></td><td><code>0x55</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0001 0001</code></td><td><code>0x00000011</code></td><td><code>1001 1001</code></td><td><code>0x99</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0001 0010</code></td><td><code>0x00000012</code></td><td><code>1110 1110</code></td><td><code>0xEE</code></td></tr><tr><td><code>0000 0000 0000 0000 0000 0000 0001 0010</code></td><td><code>0x00000013</code></td><td><code>1100 1100</code></td><td><code>0xDD</code></td></tr></tbody></table><p>A 32-bit CPU can reference up to <code>2^{32}</code>, which equals exactly 4 GB of memory (4,294,967,296 memory locations). This is called addressable memory and it is the maximum amount of memory that a CPU can reference using its addresses.</p><h3 id=physical-and-addressable-memory>Physical and Addressable Memory</h3><p>Physical memory is the actual RAM installed in the system and it is often less than the maximum addressable memory. Some addresses are reserved for system devices or hardware I/O, so not all addresses map to physical RAM.</p><p>In comparison, a 16-bit CPU can address up to 65,536 bytes, which equals 64 KB of addressable memory, while a 64-bit CPU can theoretically address up to 18,446,744,065,119,617,025 KB, or 16,384 PB of memory.</p><h3 id=physical-and-virtual-memory>Physical and Virtual Memory</h3><p>Operating systems use virtual memory to allow processes to work as if they have the full addressable space, even if physical RAM is smaller.</p><p>For 32-bit architectures virtual addresses go from <code>0x00000000</code> to <code>0xFFFFFFFF</code>. This does not correspond to physical RAM addresses. Multiple processes can have the same virtual addresses that map to different physical memory locations.</p><p>Physical RAM is shared among all processes. Virtual addresses are translated to physical addresses by the CPU using page tables. So, for example, the stack of one program isn’t actually at the same place in RAM as the stack of another program, even if they both see 0xFFFFFFFF in their own virtual space.</p><h2 id=endianess>Endianess</h2><p>When a CPU stores values larger than one byte, such as 2-byte, 4-byte, or 8-byte numbers, it must decide the order in which the bytes are stored in memory. This ordering is called endianness:</p><ul><li>Big-endian: the most significant byte (MSB) is stored at the lowest memory address.</li><li>Little-endian: the least significant byte (LSB) is stored at the lowest memory address.</li></ul><p>For example, using the table above, the values would be arranged differently in memory depending on the endianness.</p><table><thead><tr><th>Address</th><th>Data</th></tr></thead><tbody><tr><td><code>0x00000000</code></td><td><code>0x000F1011</code></td></tr><tr><td><code>0x00000004</code></td><td><code>0x121A1F20</code></td></tr><tr><td><code>0x00000008</code></td><td><code>0x242F3F4F</code></td></tr><tr><td><code>0x0000000C</code></td><td><code>0x8FAFFFAA</code></td></tr><tr><td><code>0x00000010</code></td><td><code>0x5599EEDD</code></td></tr></tbody></table><p>While in litte endian, it would be:</p><table><thead><tr><th>Address</th><th>Data</th></tr></thead><tbody><tr><td><code>0x00000000</code></td><td><code>0x11100F00</code></td></tr><tr><td><code>0x00000004</code></td><td><code>0x201F1A12</code></td></tr><tr><td><code>0x00000008</code></td><td><code>0x4F3F2F24</code></td></tr><tr><td><code>0x0000000C</code></td><td><code>0xAAFFAF8F</code></td></tr><tr><td><code>0x00000010</code></td><td><code>0xDDEE9955</code></td></tr></tbody></table><p>As another example, the 16-bit value <code>0xCAFE</code> would be stored as <code>FECA0000</code> in little-endian format and as <code>0000CAFE</code> in big-endian format. Note that the leading zeros are typically displayed when showing memory contents in fixed-width formats.</p><h2 id=word-size-and-memory-access>Word Size and Memory Access</h2><p>The word size of a CPU refers to the number of bits it processes or moves at a time. For example, a 32-bit CPU works with 32-bit (4-byte) chunks, while a 64-bit CPU works with 64-bit (8-byte) chunks. Larger word sizes allow the CPU to handle bigger numbers and process more data at once, improving performance.</p><p>Even though memory is addressed one byte at a time, CPUs typically read and write data in units of their word size. To support this, memory is often organized and accessed in aligned blocks, meaning that multi-byte values are stored at addresses that are multiples of the CPU’s word size. Aligned access is faster and more efficient, while misaligned access can slow down execution or even cause hardware exceptions on some systems.</p><p>Word size also determines how the CPU interprets multi-byte values in memory. When reading a word, the CPU must know the system&rsquo;s endianness, whether the most significant or least significant byte comes first, so it can reconstruct the original value correctly.</p></div><div class=post-footer></div></article></main></body></html>